import { sql } from 'drizzle-orm';
import type { XataHttpDatabase } from 'drizzle-orm/xata-http';
import type { DrizzleInternal, MigrationConfig } from '../migrator';
import { readMigrationFiles } from '../migrator';

/**
 * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database
 *
 * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,
 * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.
 * @param db - drizzle db instance
 * @param config - path to migration folder generated by drizzle-kit
 */ export async function migrate<TSchema extends Record<string, unknown>>(
	db: XataHttpDatabase<TSchema>,
	config: MigrationConfig,
) {
	const migrations = readMigrationFiles(config);
	const internal = db as unknown as DrizzleInternal;
	const migrationsTable = config.migrationsTable ?? '__drizzle_migrations';
	const migrationTableCreate = sql`
		CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at bigint
		)
	`;
	await internal.session.execute(migrationTableCreate);

	const dbMigrations = (await internal.session.all(
		sql`select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`,
	)) as Array<{
		id: number;
		hash: string;
		created_at: string;
	}>;

	const lastDbMigration = dbMigrations[0];

	for await (const migration of migrations) {
		if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
			for (const stmt of migration.sql) {
				await internal.session.execute(sql.raw(stmt));
			}

			await internal.session.execute(
				sql`insert into ${
					sql.identifier(migrationsTable)
				} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`,
			);
		}
	}
}
